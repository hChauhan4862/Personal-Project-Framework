// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"SMART_OFFICE_APP/pkg/db/model"
)

func newORGEMPLOYEE(db *gorm.DB, opts ...gen.DOOption) oRGEMPLOYEE {
	_oRGEMPLOYEE := oRGEMPLOYEE{}

	_oRGEMPLOYEE.oRGEMPLOYEEDo.UseDB(db, opts...)
	_oRGEMPLOYEE.oRGEMPLOYEEDo.UseModel(&model.ORGEMPLOYEE{})

	tableName := _oRGEMPLOYEE.oRGEMPLOYEEDo.TableName()
	_oRGEMPLOYEE.ALL = field.NewAsterisk(tableName)
	_oRGEMPLOYEE.SEQID = field.NewInt64(tableName, "SEQ_ID")
	_oRGEMPLOYEE.EMPUNQCD = field.NewString(tableName, "EMP_UNQCD")
	_oRGEMPLOYEE.EMPEMAIL = field.NewString(tableName, "EMP_EMAIL")
	_oRGEMPLOYEE.EMPNAME = field.NewString(tableName, "EMP_NAME")
	_oRGEMPLOYEE.EMPCONTACTNO = field.NewString(tableName, "EMP_CONTACT_NO")
	_oRGEMPLOYEE.ALTERNATECONTACTNO = field.NewString(tableName, "ALTERNATE_CONTACT_NO")
	_oRGEMPLOYEE.GENDER = field.NewString(tableName, "GENDER")
	_oRGEMPLOYEE.IDNTCODE = field.NewString(tableName, "IDNT_CODE")
	_oRGEMPLOYEE.IDNTVALUE = field.NewString(tableName, "IDNT_VALUE")
	_oRGEMPLOYEE.DEPARTMENTCODE = field.NewString(tableName, "DEPARTMENT_CODE")
	_oRGEMPLOYEE.DEPARTMENTCODEVALUE = field.NewString(tableName, "DEPARTMENT_CODE_VALUE")
	_oRGEMPLOYEE.LOGINID = field.NewString(tableName, "LOGIN_ID")
	_oRGEMPLOYEE.PASSWORD = field.NewString(tableName, "PASSWORD")
	_oRGEMPLOYEE.PROFILEPIC = field.NewString(tableName, "PROFILE_PIC")
	_oRGEMPLOYEE.ISACTIVE = field.NewBool(tableName, "IS_ACTIVE")
	_oRGEMPLOYEE.CREATEDAT = field.NewString(tableName, "CREATED_AT")
	_oRGEMPLOYEE.UPDATEDAT = field.NewString(tableName, "UPDATED_AT")

	_oRGEMPLOYEE.fillFieldMap()

	return _oRGEMPLOYEE
}

type oRGEMPLOYEE struct {
	oRGEMPLOYEEDo

	ALL                 field.Asterisk
	SEQID               field.Int64
	EMPUNQCD            field.String
	EMPEMAIL            field.String
	EMPNAME             field.String
	EMPCONTACTNO        field.String
	ALTERNATECONTACTNO  field.String
	GENDER              field.String
	IDNTCODE            field.String
	IDNTVALUE           field.String
	DEPARTMENTCODE      field.String
	DEPARTMENTCODEVALUE field.String
	LOGINID             field.String
	PASSWORD            field.String
	PROFILEPIC          field.String
	ISACTIVE            field.Bool
	CREATEDAT           field.String
	UPDATEDAT           field.String

	fieldMap map[string]field.Expr
}

func (o oRGEMPLOYEE) Table(newTableName string) *oRGEMPLOYEE {
	o.oRGEMPLOYEEDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o oRGEMPLOYEE) As(alias string) *oRGEMPLOYEE {
	o.oRGEMPLOYEEDo.DO = *(o.oRGEMPLOYEEDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *oRGEMPLOYEE) updateTableName(table string) *oRGEMPLOYEE {
	o.ALL = field.NewAsterisk(table)
	o.SEQID = field.NewInt64(table, "SEQ_ID")
	o.EMPUNQCD = field.NewString(table, "EMP_UNQCD")
	o.EMPEMAIL = field.NewString(table, "EMP_EMAIL")
	o.EMPNAME = field.NewString(table, "EMP_NAME")
	o.EMPCONTACTNO = field.NewString(table, "EMP_CONTACT_NO")
	o.ALTERNATECONTACTNO = field.NewString(table, "ALTERNATE_CONTACT_NO")
	o.GENDER = field.NewString(table, "GENDER")
	o.IDNTCODE = field.NewString(table, "IDNT_CODE")
	o.IDNTVALUE = field.NewString(table, "IDNT_VALUE")
	o.DEPARTMENTCODE = field.NewString(table, "DEPARTMENT_CODE")
	o.DEPARTMENTCODEVALUE = field.NewString(table, "DEPARTMENT_CODE_VALUE")
	o.LOGINID = field.NewString(table, "LOGIN_ID")
	o.PASSWORD = field.NewString(table, "PASSWORD")
	o.PROFILEPIC = field.NewString(table, "PROFILE_PIC")
	o.ISACTIVE = field.NewBool(table, "IS_ACTIVE")
	o.CREATEDAT = field.NewString(table, "CREATED_AT")
	o.UPDATEDAT = field.NewString(table, "UPDATED_AT")

	o.fillFieldMap()

	return o
}

func (o *oRGEMPLOYEE) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *oRGEMPLOYEE) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 17)
	o.fieldMap["SEQ_ID"] = o.SEQID
	o.fieldMap["EMP_UNQCD"] = o.EMPUNQCD
	o.fieldMap["EMP_EMAIL"] = o.EMPEMAIL
	o.fieldMap["EMP_NAME"] = o.EMPNAME
	o.fieldMap["EMP_CONTACT_NO"] = o.EMPCONTACTNO
	o.fieldMap["ALTERNATE_CONTACT_NO"] = o.ALTERNATECONTACTNO
	o.fieldMap["GENDER"] = o.GENDER
	o.fieldMap["IDNT_CODE"] = o.IDNTCODE
	o.fieldMap["IDNT_VALUE"] = o.IDNTVALUE
	o.fieldMap["DEPARTMENT_CODE"] = o.DEPARTMENTCODE
	o.fieldMap["DEPARTMENT_CODE_VALUE"] = o.DEPARTMENTCODEVALUE
	o.fieldMap["LOGIN_ID"] = o.LOGINID
	o.fieldMap["PASSWORD"] = o.PASSWORD
	o.fieldMap["PROFILE_PIC"] = o.PROFILEPIC
	o.fieldMap["IS_ACTIVE"] = o.ISACTIVE
	o.fieldMap["CREATED_AT"] = o.CREATEDAT
	o.fieldMap["UPDATED_AT"] = o.UPDATEDAT
}

func (o oRGEMPLOYEE) clone(db *gorm.DB) oRGEMPLOYEE {
	o.oRGEMPLOYEEDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o oRGEMPLOYEE) replaceDB(db *gorm.DB) oRGEMPLOYEE {
	o.oRGEMPLOYEEDo.ReplaceDB(db)
	return o
}

type oRGEMPLOYEEDo struct{ gen.DO }

func (o oRGEMPLOYEEDo) Debug() *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Debug())
}

func (o oRGEMPLOYEEDo) WithContext(ctx context.Context) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o oRGEMPLOYEEDo) ReadDB() *oRGEMPLOYEEDo {
	return o.Clauses(dbresolver.Read)
}

func (o oRGEMPLOYEEDo) WriteDB() *oRGEMPLOYEEDo {
	return o.Clauses(dbresolver.Write)
}

func (o oRGEMPLOYEEDo) Session(config *gorm.Session) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Session(config))
}

func (o oRGEMPLOYEEDo) Clauses(conds ...clause.Expression) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o oRGEMPLOYEEDo) Returning(value interface{}, columns ...string) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o oRGEMPLOYEEDo) Not(conds ...gen.Condition) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o oRGEMPLOYEEDo) Or(conds ...gen.Condition) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o oRGEMPLOYEEDo) Select(conds ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o oRGEMPLOYEEDo) Where(conds ...gen.Condition) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o oRGEMPLOYEEDo) Order(conds ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o oRGEMPLOYEEDo) Distinct(cols ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o oRGEMPLOYEEDo) Omit(cols ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o oRGEMPLOYEEDo) Join(table schema.Tabler, on ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o oRGEMPLOYEEDo) LeftJoin(table schema.Tabler, on ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o oRGEMPLOYEEDo) RightJoin(table schema.Tabler, on ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o oRGEMPLOYEEDo) Group(cols ...field.Expr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o oRGEMPLOYEEDo) Having(conds ...gen.Condition) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o oRGEMPLOYEEDo) Limit(limit int) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o oRGEMPLOYEEDo) Offset(offset int) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o oRGEMPLOYEEDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o oRGEMPLOYEEDo) Unscoped() *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Unscoped())
}

func (o oRGEMPLOYEEDo) Create(values ...*model.ORGEMPLOYEE) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o oRGEMPLOYEEDo) CreateInBatches(values []*model.ORGEMPLOYEE, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o oRGEMPLOYEEDo) Save(values ...*model.ORGEMPLOYEE) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o oRGEMPLOYEEDo) First() (*model.ORGEMPLOYEE, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGEMPLOYEE), nil
	}
}

func (o oRGEMPLOYEEDo) Take() (*model.ORGEMPLOYEE, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGEMPLOYEE), nil
	}
}

func (o oRGEMPLOYEEDo) Last() (*model.ORGEMPLOYEE, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGEMPLOYEE), nil
	}
}

func (o oRGEMPLOYEEDo) Find() ([]*model.ORGEMPLOYEE, error) {
	result, err := o.DO.Find()
	return result.([]*model.ORGEMPLOYEE), err
}

func (o oRGEMPLOYEEDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ORGEMPLOYEE, err error) {
	buf := make([]*model.ORGEMPLOYEE, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o oRGEMPLOYEEDo) FindInBatches(result *[]*model.ORGEMPLOYEE, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o oRGEMPLOYEEDo) Attrs(attrs ...field.AssignExpr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o oRGEMPLOYEEDo) Assign(attrs ...field.AssignExpr) *oRGEMPLOYEEDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o oRGEMPLOYEEDo) Joins(fields ...field.RelationField) *oRGEMPLOYEEDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o oRGEMPLOYEEDo) Preload(fields ...field.RelationField) *oRGEMPLOYEEDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o oRGEMPLOYEEDo) FirstOrInit() (*model.ORGEMPLOYEE, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGEMPLOYEE), nil
	}
}

func (o oRGEMPLOYEEDo) FirstOrCreate() (*model.ORGEMPLOYEE, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGEMPLOYEE), nil
	}
}

func (o oRGEMPLOYEEDo) FindByPage(offset int, limit int) (result []*model.ORGEMPLOYEE, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o oRGEMPLOYEEDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o oRGEMPLOYEEDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o oRGEMPLOYEEDo) Delete(models ...*model.ORGEMPLOYEE) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *oRGEMPLOYEEDo) withDO(do gen.Dao) *oRGEMPLOYEEDo {
	o.DO = *do.(*gen.DO)
	return o
}
