// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"SMART_OFFICE_APP/pkg/db/model"
)

func newORGDAILYTIME(db *gorm.DB, opts ...gen.DOOption) oRGDAILYTIME {
	_oRGDAILYTIME := oRGDAILYTIME{}

	_oRGDAILYTIME.oRGDAILYTIMEDo.UseDB(db, opts...)
	_oRGDAILYTIME.oRGDAILYTIMEDo.UseModel(&model.ORGDAILYTIME{})

	tableName := _oRGDAILYTIME.oRGDAILYTIMEDo.TableName()
	_oRGDAILYTIME.ALL = field.NewAsterisk(tableName)
	_oRGDAILYTIME.LOCATION = field.NewString(tableName, "LOCATION")
	_oRGDAILYTIME.LOCATIONID = field.NewInt64(tableName, "LOCATION_ID")
	_oRGDAILYTIME.TIMETYPE = field.NewString(tableName, "TIME_TYPE")
	_oRGDAILYTIME.ALWAYSOPEN = field.NewString(tableName, "ALWAYS_OPEN")
	_oRGDAILYTIME.ALWAYSCLOSE = field.NewString(tableName, "ALWAYS_CLOSE")
	_oRGDAILYTIME.SUNDAY = field.NewBool(tableName, "SUNDAY")
	_oRGDAILYTIME.SUNDAYOPEN = field.NewString(tableName, "SUNDAY_OPEN")
	_oRGDAILYTIME.SUNDAYCLOSE = field.NewString(tableName, "SUNDAY_CLOSE")
	_oRGDAILYTIME.MONDAY = field.NewBool(tableName, "MONDAY")
	_oRGDAILYTIME.MONDAYOPEN = field.NewString(tableName, "MONDAY_OPEN")
	_oRGDAILYTIME.MONDAYCLOSE = field.NewString(tableName, "MONDAY_CLOSE")
	_oRGDAILYTIME.TUESDAY = field.NewBool(tableName, "TUESDAY")
	_oRGDAILYTIME.TUESDAYOPEN = field.NewString(tableName, "TUESDAY_OPEN")
	_oRGDAILYTIME.TUESDAYCLOSE = field.NewString(tableName, "TUESDAY_CLOSE")
	_oRGDAILYTIME.WEDNESDAY = field.NewBool(tableName, "WEDNESDAY")
	_oRGDAILYTIME.WEDNESDAYOPEN = field.NewString(tableName, "WEDNESDAY_OPEN")
	_oRGDAILYTIME.WEDNESDAYCLOSE = field.NewString(tableName, "WEDNESDAY_CLOSE")
	_oRGDAILYTIME.THURSDAY = field.NewBool(tableName, "THURSDAY")
	_oRGDAILYTIME.THURSDAYOPEN = field.NewString(tableName, "THURSDAY_OPEN")
	_oRGDAILYTIME.THURSDAYCLOSE = field.NewString(tableName, "THURSDAY_CLOSE")
	_oRGDAILYTIME.FRIDAY = field.NewBool(tableName, "FRIDAY")
	_oRGDAILYTIME.FRIDAYOPEN = field.NewString(tableName, "FRIDAY_OPEN")
	_oRGDAILYTIME.FRIDAYCLOSE = field.NewString(tableName, "FRIDAY_CLOSE")
	_oRGDAILYTIME.SATURDAY = field.NewBool(tableName, "SATURDAY")
	_oRGDAILYTIME.SATURDAYOPEN = field.NewString(tableName, "SATURDAY_OPEN")
	_oRGDAILYTIME.SATURDAYCLOSE = field.NewString(tableName, "SATURDAY_CLOSE")

	_oRGDAILYTIME.fillFieldMap()

	return _oRGDAILYTIME
}

type oRGDAILYTIME struct {
	oRGDAILYTIMEDo

	ALL            field.Asterisk
	LOCATION       field.String
	LOCATIONID     field.Int64
	TIMETYPE       field.String
	ALWAYSOPEN     field.String
	ALWAYSCLOSE    field.String
	SUNDAY         field.Bool
	SUNDAYOPEN     field.String
	SUNDAYCLOSE    field.String
	MONDAY         field.Bool
	MONDAYOPEN     field.String
	MONDAYCLOSE    field.String
	TUESDAY        field.Bool
	TUESDAYOPEN    field.String
	TUESDAYCLOSE   field.String
	WEDNESDAY      field.Bool
	WEDNESDAYOPEN  field.String
	WEDNESDAYCLOSE field.String
	THURSDAY       field.Bool
	THURSDAYOPEN   field.String
	THURSDAYCLOSE  field.String
	FRIDAY         field.Bool
	FRIDAYOPEN     field.String
	FRIDAYCLOSE    field.String
	SATURDAY       field.Bool
	SATURDAYOPEN   field.String
	SATURDAYCLOSE  field.String

	fieldMap map[string]field.Expr
}

func (o oRGDAILYTIME) Table(newTableName string) *oRGDAILYTIME {
	o.oRGDAILYTIMEDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o oRGDAILYTIME) As(alias string) *oRGDAILYTIME {
	o.oRGDAILYTIMEDo.DO = *(o.oRGDAILYTIMEDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *oRGDAILYTIME) updateTableName(table string) *oRGDAILYTIME {
	o.ALL = field.NewAsterisk(table)
	o.LOCATION = field.NewString(table, "LOCATION")
	o.LOCATIONID = field.NewInt64(table, "LOCATION_ID")
	o.TIMETYPE = field.NewString(table, "TIME_TYPE")
	o.ALWAYSOPEN = field.NewString(table, "ALWAYS_OPEN")
	o.ALWAYSCLOSE = field.NewString(table, "ALWAYS_CLOSE")
	o.SUNDAY = field.NewBool(table, "SUNDAY")
	o.SUNDAYOPEN = field.NewString(table, "SUNDAY_OPEN")
	o.SUNDAYCLOSE = field.NewString(table, "SUNDAY_CLOSE")
	o.MONDAY = field.NewBool(table, "MONDAY")
	o.MONDAYOPEN = field.NewString(table, "MONDAY_OPEN")
	o.MONDAYCLOSE = field.NewString(table, "MONDAY_CLOSE")
	o.TUESDAY = field.NewBool(table, "TUESDAY")
	o.TUESDAYOPEN = field.NewString(table, "TUESDAY_OPEN")
	o.TUESDAYCLOSE = field.NewString(table, "TUESDAY_CLOSE")
	o.WEDNESDAY = field.NewBool(table, "WEDNESDAY")
	o.WEDNESDAYOPEN = field.NewString(table, "WEDNESDAY_OPEN")
	o.WEDNESDAYCLOSE = field.NewString(table, "WEDNESDAY_CLOSE")
	o.THURSDAY = field.NewBool(table, "THURSDAY")
	o.THURSDAYOPEN = field.NewString(table, "THURSDAY_OPEN")
	o.THURSDAYCLOSE = field.NewString(table, "THURSDAY_CLOSE")
	o.FRIDAY = field.NewBool(table, "FRIDAY")
	o.FRIDAYOPEN = field.NewString(table, "FRIDAY_OPEN")
	o.FRIDAYCLOSE = field.NewString(table, "FRIDAY_CLOSE")
	o.SATURDAY = field.NewBool(table, "SATURDAY")
	o.SATURDAYOPEN = field.NewString(table, "SATURDAY_OPEN")
	o.SATURDAYCLOSE = field.NewString(table, "SATURDAY_CLOSE")

	o.fillFieldMap()

	return o
}

func (o *oRGDAILYTIME) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *oRGDAILYTIME) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 26)
	o.fieldMap["LOCATION"] = o.LOCATION
	o.fieldMap["LOCATION_ID"] = o.LOCATIONID
	o.fieldMap["TIME_TYPE"] = o.TIMETYPE
	o.fieldMap["ALWAYS_OPEN"] = o.ALWAYSOPEN
	o.fieldMap["ALWAYS_CLOSE"] = o.ALWAYSCLOSE
	o.fieldMap["SUNDAY"] = o.SUNDAY
	o.fieldMap["SUNDAY_OPEN"] = o.SUNDAYOPEN
	o.fieldMap["SUNDAY_CLOSE"] = o.SUNDAYCLOSE
	o.fieldMap["MONDAY"] = o.MONDAY
	o.fieldMap["MONDAY_OPEN"] = o.MONDAYOPEN
	o.fieldMap["MONDAY_CLOSE"] = o.MONDAYCLOSE
	o.fieldMap["TUESDAY"] = o.TUESDAY
	o.fieldMap["TUESDAY_OPEN"] = o.TUESDAYOPEN
	o.fieldMap["TUESDAY_CLOSE"] = o.TUESDAYCLOSE
	o.fieldMap["WEDNESDAY"] = o.WEDNESDAY
	o.fieldMap["WEDNESDAY_OPEN"] = o.WEDNESDAYOPEN
	o.fieldMap["WEDNESDAY_CLOSE"] = o.WEDNESDAYCLOSE
	o.fieldMap["THURSDAY"] = o.THURSDAY
	o.fieldMap["THURSDAY_OPEN"] = o.THURSDAYOPEN
	o.fieldMap["THURSDAY_CLOSE"] = o.THURSDAYCLOSE
	o.fieldMap["FRIDAY"] = o.FRIDAY
	o.fieldMap["FRIDAY_OPEN"] = o.FRIDAYOPEN
	o.fieldMap["FRIDAY_CLOSE"] = o.FRIDAYCLOSE
	o.fieldMap["SATURDAY"] = o.SATURDAY
	o.fieldMap["SATURDAY_OPEN"] = o.SATURDAYOPEN
	o.fieldMap["SATURDAY_CLOSE"] = o.SATURDAYCLOSE
}

func (o oRGDAILYTIME) clone(db *gorm.DB) oRGDAILYTIME {
	o.oRGDAILYTIMEDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o oRGDAILYTIME) replaceDB(db *gorm.DB) oRGDAILYTIME {
	o.oRGDAILYTIMEDo.ReplaceDB(db)
	return o
}

type oRGDAILYTIMEDo struct{ gen.DO }

func (o oRGDAILYTIMEDo) Debug() *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Debug())
}

func (o oRGDAILYTIMEDo) WithContext(ctx context.Context) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o oRGDAILYTIMEDo) ReadDB() *oRGDAILYTIMEDo {
	return o.Clauses(dbresolver.Read)
}

func (o oRGDAILYTIMEDo) WriteDB() *oRGDAILYTIMEDo {
	return o.Clauses(dbresolver.Write)
}

func (o oRGDAILYTIMEDo) Session(config *gorm.Session) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Session(config))
}

func (o oRGDAILYTIMEDo) Clauses(conds ...clause.Expression) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o oRGDAILYTIMEDo) Returning(value interface{}, columns ...string) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o oRGDAILYTIMEDo) Not(conds ...gen.Condition) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o oRGDAILYTIMEDo) Or(conds ...gen.Condition) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o oRGDAILYTIMEDo) Select(conds ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o oRGDAILYTIMEDo) Where(conds ...gen.Condition) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o oRGDAILYTIMEDo) Order(conds ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o oRGDAILYTIMEDo) Distinct(cols ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o oRGDAILYTIMEDo) Omit(cols ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o oRGDAILYTIMEDo) Join(table schema.Tabler, on ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o oRGDAILYTIMEDo) LeftJoin(table schema.Tabler, on ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o oRGDAILYTIMEDo) RightJoin(table schema.Tabler, on ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o oRGDAILYTIMEDo) Group(cols ...field.Expr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o oRGDAILYTIMEDo) Having(conds ...gen.Condition) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o oRGDAILYTIMEDo) Limit(limit int) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o oRGDAILYTIMEDo) Offset(offset int) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o oRGDAILYTIMEDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o oRGDAILYTIMEDo) Unscoped() *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Unscoped())
}

func (o oRGDAILYTIMEDo) Create(values ...*model.ORGDAILYTIME) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o oRGDAILYTIMEDo) CreateInBatches(values []*model.ORGDAILYTIME, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o oRGDAILYTIMEDo) Save(values ...*model.ORGDAILYTIME) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o oRGDAILYTIMEDo) First() (*model.ORGDAILYTIME, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGDAILYTIME), nil
	}
}

func (o oRGDAILYTIMEDo) Take() (*model.ORGDAILYTIME, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGDAILYTIME), nil
	}
}

func (o oRGDAILYTIMEDo) Last() (*model.ORGDAILYTIME, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGDAILYTIME), nil
	}
}

func (o oRGDAILYTIMEDo) Find() ([]*model.ORGDAILYTIME, error) {
	result, err := o.DO.Find()
	return result.([]*model.ORGDAILYTIME), err
}

func (o oRGDAILYTIMEDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ORGDAILYTIME, err error) {
	buf := make([]*model.ORGDAILYTIME, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o oRGDAILYTIMEDo) FindInBatches(result *[]*model.ORGDAILYTIME, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o oRGDAILYTIMEDo) Attrs(attrs ...field.AssignExpr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o oRGDAILYTIMEDo) Assign(attrs ...field.AssignExpr) *oRGDAILYTIMEDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o oRGDAILYTIMEDo) Joins(fields ...field.RelationField) *oRGDAILYTIMEDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o oRGDAILYTIMEDo) Preload(fields ...field.RelationField) *oRGDAILYTIMEDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o oRGDAILYTIMEDo) FirstOrInit() (*model.ORGDAILYTIME, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGDAILYTIME), nil
	}
}

func (o oRGDAILYTIMEDo) FirstOrCreate() (*model.ORGDAILYTIME, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ORGDAILYTIME), nil
	}
}

func (o oRGDAILYTIMEDo) FindByPage(offset int, limit int) (result []*model.ORGDAILYTIME, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o oRGDAILYTIMEDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o oRGDAILYTIMEDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o oRGDAILYTIMEDo) Delete(models ...*model.ORGDAILYTIME) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *oRGDAILYTIMEDo) withDO(do gen.Dao) *oRGDAILYTIMEDo {
	o.DO = *do.(*gen.DO)
	return o
}
